/* CSCI 347 micro-make * * 09 AUG 2017, Aran Clauson */#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/wait.h>#include <ctype.h>#include <string.h>#include "arg_parse.h"#include "target.h"/* CONSTANTS *//* PROTOTYPES *//* Parse Arguments * returns an array of pointers that point to characters in line *//* Process Line * line	 The command line to execute. * This function interprets line as a command line.	It creates a new child * process to execute the line and waits for that process to complete. */void processline(char* line);/* Main entry point. * argc		A count of command-line arguments * argv		The command-line argument valus * * Micro-make (umake) reads from the uMakefile in the current working * directory.	The file is read one line at a time.	Lines with a leading tab * character ('\t') are interpreted as a command and passed to processline minus * the leading tab. */int main(int argc, const char* argv[]) {	FILE* makefile = fopen("./uMakefile", "r");	size_t	bufsize = 0;	char*	 line		= NULL;	ssize_t linelen = getline(&line, &bufsize, makefile);	int targetFound = 0;	int currRulesfound = 0;	tempTarget* currTarget;	char* targetCheck;	char* nullRule ='\0';	while(-1 != linelen) {		if(line[linelen-1]=='\n') {			linelen -= 1;			line[linelen] = '\0';		}		targetCheck = strchr(line, ':');		if(targetCheck != NULL && targetFound == 1 && currRulesfound == 0){			//New target found, no rules found for target			//end of current target's rules			/*			dprintf(2, "Line: %s \n", line);			dprintf(2, "Name: %s \n", currTarget->targetName);			dprintf(2, "Dependencies: %s \n \n", currTarget->dependencies);			*/			addNode(currTarget->targetName, currTarget->dependencies, nullRule);			findTargetnode(currTarget->targetName, tList);			targetFound = 0;			currRulesfound = 0;		}		if(isspace(line[0]) == 0 && line[0] != '\0' && targetFound == 0 && targetCheck != NULL){			//general target case			targetFound = 1;			currTarget = target_parse(&line[0]);			//dprintf(2, "Target Found: %s \n", currTarget->targetName);		  //dprintf(2, "Dependencies: %s \n \n", currTarget->dependencies);		}		/*			dprintf(2, "Target Found: %s \n", currTarget->targetName);		  dprintf(2, "Dependencies: %s \n", currTarget->dependencies);			dprintf(2, "targetFound: %d  \n", targetFound);			dprintf(2, "CurrLine: %s \n \n", line);			*/		if(line[0] == '\t' && targetFound == 1){			//assumes that this line is one of target's rules			//add to node			/*			dprintf(2, "Rule found for target: %s \n", currTarget->targetName);		  dprintf(2, "Dependencies: %s \n", currTarget->dependencies);		  dprintf(2, "Curr Rule: %s \n \n", line);			*/			addNode(currTarget->targetName, currTarget->dependencies, line);			findTargetnode(currTarget->targetName, tList);			targetFound = 0;			currRulesfound = 0;		}else if(line[0] == '\t'){			//general processing			//processline(&line[1]);			currRulesfound = 1;		}		//dprintf(2, "currRulesfound: %d  \n \n", currRulesfound);		linelen = getline(&line, &bufsize, makefile);	}	if(targetFound == 1 && line[0] != '\t'){			//check for last target(that doesnt have rules)			addNode(currTarget->targetName, currTarget->dependencies, nullRule);			findTargetnode(currTarget->targetName, tList);		}	free(currTarget);	free(line);	return EXIT_SUCCESS;}/* Process Line * */void processline (char* line) {	char** arguments;	int argcp = 0;	arguments = arg_parse(line, &argcp);	const pid_t cpid = fork();	switch(cpid) {	case -1: {		perror("fork");		break;	}	case 0: {		execvp(arguments[0],arguments);		perror("execvp");		exit(EXIT_FAILURE);		break;	}	default: {		int	 status;		const pid_t pid = wait(&status);		if(-1 == pid) {			perror("wait");		}		else if (pid != cpid) {			fprintf(stderr, "wait: expected process %d, but waited for process %d",							cpid, pid);		}		free(arguments);		break;	}	}}