/* CSCI 347 micro-make * * 09 AUG 2017, Aran Clauson */#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/wait.h>#include <ctype.h>#include "arg_parse.h"/* CONSTANTS *//* PROTOTYPES *//* Parse Arguments * returns an array of pointers that point to characters in line *//* Process Line * line	 The command line to execute. * This function interprets line as a command line.	It creates a new child * process to execute the line and waits for that process to complete. */void processline(char* line);/* Main entry point. * argc		A count of command-line arguments * argv		The command-line argument valus * * Micro-make (umake) reads from the uMakefile in the current working * directory.	The file is read one line at a time.	Lines with a leading tab * character ('\t') are interpreted as a command and passed to processline minus * the leading tab. */int main(int argc, const char* argv[]) {	FILE* makefile = fopen("./uMakefile", "r");	size_t	bufsize = 0;	char*	 line		= NULL;	ssize_t linelen = getline(&line, &bufsize, makefile);	tempTarget* currTarget;	while(-1 != linelen) {		if(line[linelen-1]=='\n') {			linelen -= 1;			line[linelen] = '\0';		}		if(isspace(line[0]) == 0 && line[0] != '\0'){ // if line is target			currTarget = target_parse(&line[0]);			dprintf(2, "currtarget: %s \n \n", currTarget->targetName);			dprintf(2, "currdependencies: %s \n \n", currTarget->dependencies);		}		else if(line[0] == '\t'){			//processline(&line[1]);		}else{			//printf("End Target \n");		}		linelen = getline(&line, &bufsize, makefile);	}	free(currTarget);	free(line);	return EXIT_SUCCESS;}/* Process Line * */void processline (char* line) {	char** arguments;	int argcp = 0;	arguments = arg_parse(line, &argcp);	const pid_t cpid = fork();	switch(cpid) {	case -1: {		perror("fork");		break;	}	case 0: {		execvp(arguments[0],arguments);		perror("execvp");		exit(EXIT_FAILURE);		break;	}	default: {		int	 status;		const pid_t pid = wait(&status);		if(-1 == pid) {			perror("wait");		}		else if (pid != cpid) {			fprintf(stderr, "wait: expected process %d, but waited for process %d",							cpid, pid);		}		free(arguments);		break;	}	}}