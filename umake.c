/* CSCI 347 micro-make *  * 09 AUG 2017, Aran Clauson */#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/wait.h>#include <ctype.h>/* CONSTANTS *//* PROTOTYPES *//* Parse Arguments * returns an array of pointers that point to characters in line */int countArg(char* line); //helper function that counts argschar** arg_parse(char* line);/* Process Line * line   The command line to execute. * This function interprets line as a command line.  It creates a new child * process to execute the line and waits for that process to complete.  */void processline(char* line);/* Main entry point. * argc    A count of command-line arguments  * argv    The command-line argument valus * * Micro-make (umake) reads from the uMakefile in the current working * directory.  The file is read one line at a time.  Lines with a leading tab * character ('\t') are interpreted as a command and passed to processline minus * the leading tab. */int main(int argc, const char* argv[]) {  FILE* makefile = fopen("./uMakefile", "r");  size_t  bufsize = 0;  char*   line    = NULL;  ssize_t linelen = getline(&line, &bufsize, makefile);   while(-1 != linelen) {    if(line[linelen-1]=='\n') {      linelen -= 1;      line[linelen] = '\0';    }    if(line[0] == '\t')       processline(&line[1]);    linelen = getline(&line, &bufsize, makefile);  }  free(line);  return EXIT_SUCCESS;}/* Helper function for arg_parse * Takes in copy of pointer and counts number of arguments */int countArg(char* line){	int aCounter = 0;        int argFound = 0;	while(*line != '\0'){		            if(*line != ' ' && argFound == 0){                argFound++;                if(argFound == 1){                    aCounter++;                }                line++;            }else{                if(*line != '\0' && !isspace(*line)){                    argFound++;                    line++;                 }else if (isspace(*line)){                    argFound = 0;                    line++;                }            }	}        return aCounter;}/* Parse Argument * Takes original pointer and processes it to parse arguments and insert null in * the first whitespace it finds after an argument */char** arg_parse(char* line) {        char* currArg;	int argsInserted = 0;        int aCounter = 0;        char* lineDup = line;                aCounter = countArg(lineDup);        aCounter++;        char** arguments = (char**) malloc(aCounter*sizeof(char*));         arguments[aCounter-1] = 0L;	while(*line != '\0'){		if(isspace(*line)){			line++;		}else{			currArg = line;			arguments[argsInserted] = currArg;			argsInserted++;			while(!isspace(*line) && *line != '\0'){                            dprintf(2, "Char found skipping, %s \n", line);                             line++;			}			if(isspace(*line)){                                                  *line = '\0';                            line++;  			}			if (*line == '\0'){                            break;                        }		} 	}        return arguments;} /* Process Line *  */void processline (char* line) {    //modify processline to use arg_parse  printf("Calling arg_parse \n");  char** test;  test = arg_parse(line);  printf("test: %c\n", *test[0]);    const pid_t cpid = fork();  switch(cpid) {  case -1: {    perror("fork");    break;  }  case 0: {    execvp(test[0],test);    perror("execvp");    exit(EXIT_FAILURE);    break;  }  default: {    int   status;    const pid_t pid = wait(&status);    if(-1 == pid) {      perror("wait");    }    else if (pid != cpid) {      fprintf(stderr, "wait: expected process %d, but waited for process %d",              cpid, pid);    }    break;  }  }}