/* CSCI 347 micro-make *  * 09 AUG 2017, Aran Clauson */#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/wait.h>#include <ctype.h>/* CONSTANTS *//* PROTOTYPES *//* Parse Arguments * returns an array of pointers that point to characters in line */int countArg(char* line); //helper function that counts argschar** arg_parse(char* line);/* Process Line * line   The command line to execute. * This function interprets line as a command line.  It creates a new child * process to execute the line and waits for that process to complete.  */void processline(char* line);/* Main entry point. * argc    A count of command-line arguments  * argv    The command-line argument valus * * Micro-make (umake) reads from the uMakefile in the current working * directory.  The file is read one line at a time.  Lines with a leading tab * character ('\t') are interpreted as a command and passed to processline minus * the leading tab. */int main(int argc, const char* argv[]) {  FILE* makefile = fopen("./uMakefile", "r");  size_t  bufsize = 0;  char*   line    = NULL;  ssize_t linelen = getline(&line, &bufsize, makefile);   while(-1 != linelen) {    if(line[linelen-1]=='\n') {      linelen -= 1;      line[linelen] = '\0';    }    if(line[0] == '\t')       processline(&line[1]);    linelen = getline(&line, &bufsize, makefile);  }  free(line);  return EXIT_SUCCESS;}/* Helper function for arg_parse * Counts number of arguments *///Currently assuming that this function works correctlyint countArg(char* line){	//Storing starting position		int aCounter = 0;        int argFound = 0;        //printf("Arg found, pointer: %s \n", line);	//Iterate through line and find number of arguments	while(*line != '\0'){            //have 2 flags,             //one that detects when a char is found, iterate until you find a whitespace		            if(*line != ' ' && argFound == 0){                //char found                argFound++;                if(argFound == 1){                    aCounter++; //arg found                }                //printf("Arg found, pointer: %s \n", line);                line++;            }else{                if(*line != '\0' && !isspace(*line)){                    //if pointer already at null dont increment                    //skipping extra characters                    //printf("Skip, pointer: %s \n", line);                    argFound++;                    line++; //test input for longer arguments                }else if (isspace(*line)){                    //reset argfound when whitespace is found                    argFound = 0;                    line++;                }            }	}	//printf("Number of args successfully counted \n");        //printf("Pointer in countArg: %s \n", line);        return aCounter;}/* Parse Argument * Should return an array of pointers */char** arg_parse(char* line) {        //copying pointer to count args        int aCounter = 0;        char* lineDup = line;        printf("Counting number of args \n");        aCounter = countArg(lineDup);        printf("Pointer in arg_parse: %s \n", line);        printf("Number of args: %d \n", aCounter);        aCounter++;        printf("Total space for args: %d \n", aCounter);        char** arguments = (char**) malloc(aCounter*sizeof(char*));         arguments[aCounter-1] = 0L;        dprintf(2, "Point 1 \n");         	char* currArg;	int argsInserted = 0;	//Array is now created using malloc        	//Iterate through line again and store pointer location of first char of argument.	//Store in char** array	//Iterate until you find a whitespace or null pointer. Repeat	while(*line != '\0'){		//first character is not null, arg is not null		if(isspace(*line)){			//Whitespace skip			line++;                        dprintf(2, "White space found, %s \n", line); 		}else{			//Something other than a whitespace found			//Store pointer in array			currArg = line;                        dprintf(2, "currArg: %s \n", currArg); 			arguments[argsInserted] = currArg;                        dprintf(2, "Element inserted: %s \n", arguments[argsInserted]); 			argsInserted++;			//Once you have stored the pointer location of the first char, add in a null 				pointer in the first white space after that argument			//Assume that the rest of the characters until the next whitespace are part 				of the argument. for now continue interating until next whitespace is found			while(!isspace(*line) && *line != '\0'){                            dprintf(2, "Char found skipping, %s \n", line);                             line++;			}			//at this point should be at first new whitespace that is found			if(isspace(*line)){                            //first whitespace after arg found, replace with null pointer                                                        *line = '\0';                            dprintf(2, "Inserting null pointer, %s \n", arguments[argsInserted]);                             line++; // seg fault here probably because the entire line is set to null instead of the one character.                            //break points for gdb                            //0x0000000000400c6b                            //0x400c2a                            //gets stuck on the end character and loops 			}			if (*line == '\0'){                            //check for when it reaches the end of line and find a null pointer                            break;                        }		} 	}	dprintf(2, "First, %s \n", arguments[0]);        dprintf(2, "Second, %s \n", arguments[1]);         dprintf(2, "Third, %s \n", arguments[2]);         return arguments;} /* Process Line *  */void processline (char* line) {    //modify processline to use arg_parse  printf("Calling arg_parse \n");  char** test;  test = arg_parse(line);  printf("test: %c\n", *test[0]);    const pid_t cpid = fork();  switch(cpid) {  case -1: {    perror("fork");    break;  }  case 0: {    execvp(test[0],test);    perror("execvp");    exit(EXIT_FAILURE);    break;  }  default: {    int   status;    const pid_t pid = wait(&status);    if(-1 == pid) {      perror("wait");    }    else if (pid != cpid) {      fprintf(stderr, "wait: expected process %d, but waited for process %d",              cpid, pid);    }    break;  }  }}