/* CSCI 347 micro-make * * 09 AUG 2017, Aran Clauson */#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/wait.h>#include <ctype.h>/* CONSTANTS *//* PROTOTYPES *//* Parse Arguments * returns an array of pointers that point to characters in line *//* Helper function * arg_parse will use this to count number of arguments */int countArg(char* line);/* Will take in a char* and return an array of pointers to each arguments * Will take and seperate line into seperate arguments using whitespace */char** arg_parse(char* line);/* Process Line * line	 The command line to execute. * This function interprets line as a command line.	It creates a new child * process to execute the line and waits for that process to complete. */void processline(char* line);/* Main entry point. * argc		A count of command-line arguments * argv		The command-line argument valus * * Micro-make (umake) reads from the uMakefile in the current working * directory.	The file is read one line at a time.	Lines with a leading tab * character ('\t') are interpreted as a command and passed to processline minus * the leading tab. */int main(int argc, const char* argv[]) {	FILE* makefile = fopen("./uMakefile", "r");	size_t	bufsize = 0;	char*	 line		= NULL;	ssize_t linelen = getline(&line, &bufsize, makefile);	while(-1 != linelen) {		if(line[linelen-1]=='\n') {			linelen -= 1;			line[linelen] = '\0';		}		if(line[0] == '\t')			processline(&line[1]);		linelen = getline(&line, &bufsize, makefile);	}	free(line);	return EXIT_SUCCESS;}/* Helper function for arg_parse * Takes in copy of pointer and counts number of arguments */int countArg(char* line){	int aCounter = 0;				int argFound = 0;	while(*line != '\0'){						if(*line != ' ' && argFound == 0){								argFound++;								if(argFound == 1){										aCounter++;								}								line++;						}else{								if(*line != '\0' && !isspace(*line)){										argFound++;										line++;								}else if (isspace(*line)){										argFound = 0;										line++;								}						}	}				return aCounter;}/* Parse Argument * Takes original pointer and processes it to parse arguments and insert null in * the first whitespace it finds after an argument */char** arg_parse(char* line) {				char* currArg;				int argsInserted = 0;				int aCounter = 0;				aCounter = countArg(line);				aCounter++;				char** arguments = (char**) malloc(aCounter*sizeof(char*));				arguments[aCounter-1] = 0;	while(*line != '\0'){		if(isspace(*line)){			line++;		}else{			currArg = line;			arguments[argsInserted] = currArg;			argsInserted++;			while(!isspace(*line) && *line != '\0'){					line++;			}			if(isspace(*line)){					*line = '\0';					line++;			}		}	}	return arguments;}/* Process Line * */void processline (char* line) {	char** arguments;	arguments = arg_parse(line);	const pid_t cpid = fork();	switch(cpid) {	case -1: {		perror("fork");		break;	}	case 0: {		execvp(arguments[0],arguments);		perror("execvp");		exit(EXIT_FAILURE);		break;	}	default: {		int	 status;		const pid_t pid = wait(&status);		if(-1 == pid) {			perror("wait");		}		else if (pid != cpid) {			fprintf(stderr, "wait: expected process %d, but waited for process %d",							cpid, pid);		}		free(arguments);		break;	}	}}