/* CSCI 347 micro-make * * 09 AUG 2017, Aran Clauson */#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/wait.h>#include <ctype.h>#include <string.h>#include "arg_parse.h"#include "target.h"#include "umake.h"/*	WORKNOTE: work on issue 9 first, execute target dependencies and follow them in order	good information on makefiles: https://www.codeproject.com/Articles/31488/Makefiles-in-Linux-An-Overview*//* CONSTANTS *//* PROTOTYPES *//* Parse Arguments * returns an array of pointers that point to characters in line *//* parseCommands * Handles parsing command line arguments * makes sure to check that the target being parsed has rules * if not, prints that there are no rules * if target has rules, calls helper function to output */void parseCommands(int argc, const char* argv[]);/* Process Line * line	 The command line to execute. * This function interprets line as a command line.	It creates a new child * process to execute the line and waits for that process to complete. */void processline(char* line);/* Main entry point. * argc		A count of command-line arguments * argv		The command-line argument valus * * Micro-make (umake) reads from the uMakefile in the current working * directory.	The file is read one line at a time.	Lines with a leading tab * character ('\t') are interpreted as a command and passed to processline minus * the leading tab. * * Main Adjustments made by student: * Program now runs in two modes, target mode and argument mode. Depending on the * first line of the file it will determine whether or not to parse for targets. * Once it is parsing for targets it will look for a : on the current line. * If it finds one it will split and store the current line's (target) information * temporarily while it continues to look if the target has rules. * If another target is found it assumes the previous target didn't have rules and * adds it to the linked list. * If a rule(s) is found it creates a node in a rule list. If a node was created * previously and a new target is found the program will copy the rule list to * a target node created using the previous target's information and adds * to global list. * * Many checks were added to handle different use cases. */int main(int argc, const char* argv[]) {	FILE* makefile = fopen("./uMakefile", "r");	size_t	bufsize = 0;	char*	 line		= NULL;	ssize_t linelen = getline(&line, &bufsize, makefile);	tempTarget* currTarget;	char* targetCheck;	int targetFound = 0;	int currRulesfound = 0;	int mode = 0;	tList = malloc(sizeof(targetList));	rList = malloc(sizeof(ruleList));	/* This check here determines what mode program is in	 * 0 = execute arguments normally	 * 1 = targets	 */	targetCheck = strchr(line, ':');	if(targetCheck != NULL){		mode = 1;	}	while(-1 != linelen) {		if(line[linelen-1]=='\n') {			linelen -= 1;			line[linelen] = '\0';		}		if(mode == 1){			/* TARGET COLLECTION			 *			 */			targetCheck = strchr(line, ':');			if(targetCheck != NULL && targetFound == 1 && currRulesfound == 0){				//end of current target's rules				//copy memory and data of ruleslist and add node				ruleList* inputRules = malloc(sizeof(ruleList));				inputRules = memcpy(inputRules, rList, sizeof(ruleList));				addNode(currTarget->targetName, currTarget->dependencies, inputRules);				//frees and resets rule list once current set is added				free(rList);				rList = malloc(sizeof(ruleList));				targetFound = 0;				currRulesfound = 0;			}			if(isspace(line[0]) == 0 && line[0] != '\0' && targetFound == 0 && targetCheck != NULL){				//general target case				targetFound = 1;				currRulesfound = 0;				currTarget = target_parse(&line[0]);			}			linelen = getline(&line, &bufsize, makefile);			/* CHECKS NEXT LINE FOR RULES			 * RULE COLLECTION			 */			if(strchr(line, ':') == NULL){				if(linelen != -1){						if(line[0] == '\t' && targetFound == 1){						//assumes that this line is one of target's rules						//add to current rule list						addRule(line);						currRulesfound = 1;					}				}else{					//Last line in stream, is also a rule so need to add last node					ruleList* inputRules = malloc(sizeof(ruleList));					inputRules = memcpy(inputRules, rList, sizeof(ruleList));					addNode(currTarget->targetName, currTarget->dependencies, inputRules);				}			}else{				//next line is a target, flag to add node				currRulesfound = 0;			}		}else{			/* NORMAL ARGUMENT EXECUTION			 *			 */			processline(&line[1]);			linelen = getline(&line, &bufsize, makefile);		}	}	if(targetFound == 1 && line[0] != '\t'){			//check for last target(that doesnt have rules)			addNode(currTarget->targetName, currTarget->dependencies, rList);	}	parseCommands(argc, argv);	if(mode == 1){		free(currTarget->targetName);		free(currTarget->dependencies);		free(currTarget);		free(tList->currTarget);		free(rList->currRule);	}	free(tList);	free(rList);	free(line);	return EXIT_SUCCESS;}void parseCommands(int argc, const char* argv[]){	int currArg = 1;	char* currTargetReq;	void* checkList;	ruleList* outputList;	while(argv[currArg]!= '\0'){		currTargetReq = strdup(argv[currArg]);		checkList = findTargetnode(currTargetReq, tList, 1);		if(checkList == NULL){		}else{			//Check passed, it is confirmed that target has rules			outputList = (ruleList *)findTargetnode(currTargetReq, tList, 0);			traverseRules(outputList);		}		//after getting argument pass to findTargetnode and processline		currArg++;		free(currTargetReq);	}} void* traverseRules(ruleList* list){	 	if(list == NULL ||list->currRule == NULL){				return NULL;		}		else{				processline(list->currRule);			 	return traverseRules(list->next);		} }/* Process Line * */void processline (char* line) {	char** arguments;	int argcp = 0;	arguments = arg_parse(line, &argcp);	const pid_t cpid = fork();	switch(cpid) {	case -1: {		perror("fork");		break;	}	case 0: {		execvp(arguments[0],arguments);		perror("execvp");		exit(EXIT_FAILURE);		break;	}	default: {		int	 status;		const pid_t pid = wait(&status);		if(-1 == pid) {			perror("wait");		}		else if (pid != cpid) {			fprintf(stderr, "wait: expected process %d, but waited for process %d",							cpid, pid);		}		free(arguments);		break;	}	}}