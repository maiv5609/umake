/* CSCI 347 micro-make * * 09 AUG 2017, Aran Clauson */#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <sys/wait.h>#include <ctype.h>#include <string.h>#include "arg_parse.h"#include "target.h"/* CONSTANTS *//* PROTOTYPES *//* Parse Arguments * returns an array of pointers that point to characters in line *//* Iterates through command line arguments and executes targets using helper function * */void parseCommands(int argc, const char* argv[]);void* traverseRules(ruleList* list);/* Process Line * line	 The command line to execute. * This function interprets line as a command line.	It creates a new child * process to execute the line and waits for that process to complete. */void processline(char* line);/* Main entry point. * argc		A count of command-line arguments * argv		The command-line argument valus * * Micro-make (umake) reads from the uMakefile in the current working * directory.	The file is read one line at a time.	Lines with a leading tab * character ('\t') are interpreted as a command and passed to processline minus * the leading tab. */int main(int argc, const char* argv[]) {	FILE* makefile = fopen("./uMakefile", "r");	size_t	bufsize = 0;	char*	 line		= NULL;	ssize_t linelen = getline(&line, &bufsize, makefile);	tempTarget* currTarget;	char* targetCheck;	int targetFound = 0;	int currRulesfound = 0;	int mode = 0;	tList = malloc(sizeof(targetList));	rList = malloc(sizeof(ruleList));	dprintf(2, "Line: %s \n", line);	//check if parsing files with targets or just commands	targetCheck = strchr(line, ':');	if(targetCheck != NULL){		mode = 1;	}	while(-1 != linelen) {		if(line[linelen-1]=='\n') {			linelen -= 1;			line[linelen] = '\0';		}		if(mode == 1){				/* TARGET COLLECTION		 *		 */		targetCheck = strchr(line, ':');		if(targetCheck != NULL && targetFound == 1 && currRulesfound == 0){			//New target found, no rules found for target			//end of current target's rules			//copy memory and data of ruleslist			ruleList* inputRules = malloc(sizeof(ruleList));			inputRules = memcpy(inputRules, rList, sizeof(ruleList));			/*			dprintf(2, "Current head of rule list: %s \n", inputRules->currRule);			dprintf(2, "next head of rule list: %s \n \n",(inputRules->next)->currRule);			*/			addNode(currTarget->targetName, currTarget->dependencies, inputRules);			/*			dprintf(2, "Current Node information \n");			dprintf(2, "Name: %s \n", tList->currTarget);			dprintf(2, "Dependencies: %s \n", tList->dependencies);			dprintf(2, "Current head of rule list: %s \n", (tList->rules)->currRule);			dprintf(2, "next head of rule list: %s \n", ((tList->rules)->next)->currRule);			dprintf(2, "next head of rule list: %s \n \n", (((tList->rules)->next)->next)->currRule);			*/			//frees and resets rule list once current set is added			free(rList);			rList = malloc(sizeof(ruleList));			//findTargetnode(currTarget->targetName, tList);			targetFound = 0;			currRulesfound = 0;		}		if(isspace(line[0]) == 0 && line[0] != '\0' && targetFound == 0 && targetCheck != NULL){			//general target case			targetFound = 1;			currRulesfound = 0;			currTarget = target_parse(&line[0]);		}		linelen = getline(&line, &bufsize, makefile);		/* 	CHECKS FOR NEXT LINE		 *		 */		if(strchr(line, ':') == NULL){			if(linelen != -1){					/* Normal Rule Collection				  *				  */					if(line[0] == '\t' && targetFound == 1){					//assumes that this line is one of target's rules					//add to current rule list					addRule(line);					currRulesfound = 1;				}			}else{				//Last line in stream, is also a rule so need to add last node				ruleList* inputRules = malloc(sizeof(ruleList));				inputRules = memcpy(inputRules, rList, sizeof(ruleList));				addNode(currTarget->targetName, currTarget->dependencies, inputRules);			}		}else{			//next line is a target, flag to add node			//dprintf(2, "Next Line is target \n \n");			currRulesfound = 0;		}		}else{			processline(&line[1]);			linelen = getline(&line, &bufsize, makefile);		}	}	if(targetFound == 1 && line[0] != '\t'){			//check for last target(that doesnt have rules)			addNode(currTarget->targetName, currTarget->dependencies, rList);			//findTargetnode(currTarget->targetName, tList);	}	/*			dprintf(2, "Current Node information \n");			dprintf(2, "Name: %s \n", tList->currTarget);			dprintf(2, "Dependencies: %s \n", tList->dependencies);			dprintf(2, "Current head of rule list: %s \n", (tList->rules)->currRule);			dprintf(2, "next head of rule list: %s \n", ((tList->rules)->next)->currRule);			dprintf(2, "next head of rule list: %s \n \n", (((tList->rules)->next)->next)->currRule);	*/	/*	dprintf(2, "Name: %s \n", (tList->next)->currTarget);	dprintf(2, "Dependencies: %s \n", (tList->next)->dependencies);	dprintf(2, "accessing 1st Rule: %s \n",((tList->next)->rules)->currRule);	dprintf(2, "accessing 2nd Rule: %s \n",(((tList->next)->rules)->next)->currRule);	*/	parseCommands(argc, argv);	free(rList);	free(currTarget);	free(line);	return EXIT_SUCCESS;}/* Handles parsing command line arguments * makes sure to check that the target being parsed has rules * if not, prints that there are no rules * if target has rules, calls helper function to output */void parseCommands(int argc, const char* argv[]){	int currArg = 1;	char* currTargetReq;	void* checkList;	ruleList* outputList;	while(argv[currArg]!= '\0'){		currTargetReq = strdup(argv[currArg]);		printf("\nCOMMAND: %s\n", argv[currArg]);		checkList = findTargetnode(currTargetReq, tList);		if(checkList == NULL){			dprintf(2, "No rules found for %s \n \n", currTargetReq);		}else{			//Check passed, it is confirmed that target has rules			dprintf(2, "Target found \n \n");			outputList = (ruleList *)findTargetnode(currTargetReq, tList);			traverseRules(outputList);		}		//after getting argument pass to findTargetnode and processline		currArg++;		free(currTargetReq);	}}/* Helper function that traverses rulelist for parseCommands function * */ void* traverseRules(ruleList* list){	 	if(list->currRule == NULL){				return NULL;		}		else{				processline(list->currRule);			 	return traverseRules(list->next);		} }/* Process Line * */void processline (char* line) {	char** arguments;	int argcp = 0;	arguments = arg_parse(line, &argcp);	const pid_t cpid = fork();	switch(cpid) {	case -1: {		perror("fork");		break;	}	case 0: {		execvp(arguments[0],arguments);		perror("execvp");		exit(EXIT_FAILURE);		break;	}	default: {		int	 status;		const pid_t pid = wait(&status);		if(-1 == pid) {			perror("wait");		}		else if (pid != cpid) {			fprintf(stderr, "wait: expected process %d, but waited for process %d",							cpid, pid);		}		free(arguments);		break;	}	}}